;#!/opt/local/bin/sbcl.bin --core /opt/local/lib/sbcl/sbcl.core --noinform
;#!/usr/local/bin/sbcl --noinform
;#!/sw/bin/clisp
;#!/usr/local/bin/clisp
;;;;   Hey, Emacs, this is a -*- Mode: Lisp; Syntax: Common-Lisp -*- file!
;;;;
;;;;   Programming should be fun. Programs should be beautiful.
;;;;   -- Paul Graham
;;;;
;;;;   Name:               roman.lisp
;;;;
;;;;   Started:            Sun Mar  1 23:20:25 2009
;;;;   Modifications:
;;;;
;;;;   Purpose:
;;;;
;;;;
;;;;
;;;;   Calling Sequence:
;;;;
;;;;
;;;;   Inputs:
;;;;
;;;;   Outputs:
;;;;
;;;;   Example:
;;;;
;;;;   Notes:
;;;;
;;;;
(load "/Users/dsletten/lisp/packages/lang")
;(load "/Users/dsletten/lisp/regex/cl-ppcre-1.2.13/load.lisp")

(require 'asdf)
(asdf:operate 'asdf:load-op 'cl-ppcre)

(defpackage roman (:use common-lisp lang))

(in-package roman)

(defconstant roman-values-hash
  (sethash (make-hash-table :test #'equalp)
           (#\i 1) (#\v 5) (#\x 10) (#\l 50) (#\c 100) (#\d 500) (#\m 1000)))

;; (defconstant roman-values-hash (make-hash-table :test #'equalp))
;; (sethash roman-values-hash (#\i 1) (#\v 5) (#\x 10) (#\l 50) (#\c 100) (#\d 500) (#\m 1000))

(defun value (roman)
  (gethash roman roman-values-hash))

;;;
;;;    This regex cribbed from Perl's CPAN module Roman.pm (http://search.cpan.org/~chorny/Roman-1.23/lib/Roman.pm).
;;;    
(defun romanp (roman-string)
  (and (string/= roman-string "")
       (cl-ppcre:scan "^(?:M{0,3})(?:D?C{0,3}|C[DM])(?:L?X{0,3}|X[LC])(?:V?I{0,3}|I[VX])$" roman-string)))

(defun roman-to-arabic (roman-string)
  (labels ((roman-to-arabic-aux (roman-list)
             (destructuring-bind (&optional this next &rest tail) roman-list
               (declare (ignore tail))
               (cond ((endp roman-list) 0)
                     ((null next) (value this))
                     ((< (value this) (value next))
                      (- (roman-to-arabic-aux (rest roman-list))
                         (value this)))
                     (t (+ (value this)
                           (roman-to-arabic-aux (rest roman-list)))) ))))
    (if (romanp (string-upcase roman-string))
        (roman-to-arabic-aux (coerce roman-string 'list))
        (error "Bad Roman numeral."))))

;;;
;;;    The above function works correctly for all valid Roman numerals from 1 to 3999
;;;    as generated by FORMAT (which only accepts input upto 3999).
;;;
(defun test-roman-to-arabic ()
  (loop for i from 1 upto 3999
        for arabic = (roman-to-arabic (format nil "~@R" i))
        unless (= i arabic)
        do (format t "~D ~D" i arabic)))

(defconstant arabic-values '((1000 "M") (900 "CM") (500 "D") (400 "CD")
                             (100 "C") (90 "XC") (50 "L") (40 "XL")
                             (10 "X") (9 "IX") (5 "V") (4 "IV")
                             (1 "I")))

;;;
;;;    Can't get this right in order to put the whole COND inside...
;;;    (destructuring-bind ((arabic roman) &rest tail) num-list
;;;    Need to specify &optional somehow...
;;;    
(defun arabic-to-roman (n)
  (labels ((arabic-to-roman-aux (n num-list)
             (cond ((endp num-list) '())
                   ((zerop n) '())
                   (t (destructuring-bind ((arabic roman) &rest tail) num-list
                        (if (>= n arabic)
                            (cons roman (arabic-to-roman-aux (- n arabic) num-list))
                            (arabic-to-roman-aux n tail)))) )))
    (if (<= 1 n 3999)
        (apply #'concatenate 'string (arabic-to-roman-aux n arabic-values))
        (error "Bad number."))))


(defun test-arabic-to-roman ()
  (loop for i from 1 upto 3999
        for roman = (arabic-to-roman i)
        unless (string= roman (format nil "~@R" i))
        do (format t "~D ~D" i roman)))

;;;
;;;    See _Thinking Forth_ pg. 122
;;;
(defconstant roman-map '((1    #("" "I" "II" "III" "IV" "V" "VI" "VII" "VIII" "IX"))
                         (10   #("" "X" "XX" "XXX" "XL" "L" "LX" "LXX" "LXXX" "XC"))
                         (100  #("" "C" "CC" "CCC" "CD" "D" "DC" "DCC" "DCCC" "CM"))
                         (1000 #("" "M" "MM" "MMM"))))

(defun lookup (unit val)
  (aref (second (assoc unit roman-map)) val))

(defun arabic-to-roman (n)
  (do ((n n (rem n unit))
       (unit 1000 (/ unit 10))
       (result '() (cons (lookup unit (truncate n unit)) result)))
      ((< unit 1) (apply #'concatenate 'string (reverse result)))) )
